from matplotlib import pyplot as plt
from sklearn.metrics import confusion_matrix
from logistic.esitmation import Estimation
from matplotlib.colors import ListedColormap
import numpy as np
from util.path_util import getPath
import seaborn as sns
import geopandas as gpd
from shapely.geometry import Point
from mpl_toolkits.basemap import Basemap

rc = {
    "font.size": 18,
    "axes.labelsize": 18,
    "axes.titlesize": 24,
    "xtick.labelsize": 16,
    "ytick.labelsize": 16,
    "legend.fontsize": 18,

    "grid.linewidth": 1.5,
    "lines.linewidth": 3.5,
    "patch.linewidth": .3,
    "lines.markersize": 7,
    "lines.markeredgewidth": 0,
    "xtick.major.width": 1,
    "ytick.major.width": 1,
    "xtick.minor.width": .5,
    "ytick.minor.width": .5,

    "xtick.major.pad": 7,
    "ytick.major.pad": 7,
}
sns.set_context('talk', font_scale=1, rc=rc)
colors = 'bgrcmykw'
clf_names = ['rf','xgbc','lr']
def plot_confusion_matrix(label,predict,negative_label,positive_label,param):
    cf_matrix = confusion_matrix(label, predict)
    print('confusion matrix:')
    print(cf_matrix)
    print('\n')
    plt.matshow(cf_matrix)
    plt.title('Confusion matrix with C=%.2f'%param)
    plt.colorbar()
    plt.ylabel(u'real type(0 for %s, 1 for %s)'%(negative_label,positive_label))
    plt.xlabel(u'predictive type(0 for %s, 1 for %s)'%(negative_label,positive_label))
    plt.grid(False)
    plt.show()


    TP = cf_matrix[1, 1]
    TN = cf_matrix[0, 0]
    FP = cf_matrix[0, 1]
    FN = cf_matrix[1, 0]

    return {'TN':TN, 'TP':TP, 'FP':FP, 'FN':FN}

# return a dict of all kinds of scores for estimation and the desciption of these scores
def estimate_scores(label,predict):
    myEstimation = Estimation(label, predict)

    scores = myEstimation.all_score()

    myEstimation.plot_roc(label,predict)

    reurn_scores = scores.copy()

    return reurn_scores



def plot_decision_regions(X, y, classifier,labels,legend,resolution=0.02):
    """plot the decision regions.

          Parameters
          ----------
          X : {array-like, sparse matrix}, shape (n_samples, n_features)
              Training vector, where n_samples in the number of samples and
              n_features is the number of features.

          y : array-like, shape (n_samples,)
              Label vector relative to X.

          classifier: The instance of classifier, which has been trained.
                    E.g. LogisticRegression, Perceptron

          labels: The labels for xlabel and ylabel

          legend: The legend string for each ploted line

          resolution: just for plotting the decision line

          """
    # setup marker generator and color map
    markers = ('s','x','o','^','v')
    colors = ('red', 'blue','lightgreen','gray','cyan')
    cmap = ListedColormap(colors[:len(np.unique(y))])   # choose the colormap according to the number of classes

    # plot the decision surface
    x1_min, x1_max = X[:,0].min() - 1, X[:, 0].max() + 1
    x2_min, x2_max = X[:,1].min() - 1, X[:, 1].max() + 1
    xx1, xx2 = np.meshgrid(np.arange(x1_min,x1_max,resolution),
                           np.arange(x2_min,x2_max,resolution))
    Z = classifier.predict(np.array([xx1.ravel(),xx2.ravel()]).T)
    Z = Z.reshape(xx1.shape)
    plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap)
    plt.xlim(xx1.min(), xx1.max())
    plt.ylim(xx2.min(), xx2.max())

    # plot class samples
    for idx, cl in enumerate(np.unique(y)):
        plt.scatter(x=X[y == cl,0], y=X[y == cl,1],
                    alpha=0.8, c=cmap(idx),
                    marker=markers[idx],label=legend[cl])
    # set labels
    plt.xlabel(labels[0])
    plt.ylabel(labels[1])

def plot_validation_curve(param_range, train_scores, test_scores,param_name,score_name,):
    '''
        Help choose the hyperparameters of the model by validation curve,
        the figure is about (#value_parameters,scores)
        If the scores are generated by kfold, then scores.shape[1] = cv

        :param param_range: the value of parameter for each iterations with shape (1, #param_range)
        :param train_scores:  the score of each iterations with shape (#param_range, #iterations)
        :param test_scores:  the score of each iterations with shape (#param_range, #iterations)
        :param param_name: the name of parameter which are estimated
        :param score_name: the estimation baseline
        :param positive_label: the integer which indicates the positive label
        :return:
    '''
    train_mean = np.mean(train_scores, axis=1)
    train_std = np.std(train_scores, axis=1)
    test_mean = np.mean(test_scores, axis=1)
    test_std = np.std(test_scores, axis=1)

    plt.figure()
    plt.plot(param_range,train_mean,color='blue',marker='o',markersize=5,label='training %s'%score_name.lower())
    plt.fill_between(param_range, train_mean+ train_std, train_mean-train_std,alpha=0.15,color='blue')
    plt.plot(param_range,test_mean,color='green',linestyle='--',marker='s',markersize=5, label='validation %s'%score_name.lower())
    plt.fill_between(param_range,test_mean+test_std, test_mean-test_std, alpha=0.15, color='green')

    plt.xlabel('Parameter '+param_name)
    plt.ylabel(score_name)
    plt.xscale('log')   # rescale the x-axis in logarithm

    plt.legend(loc='lower right')
    plt.ylim([0.5,1.0])
    plt.show()

def plot_leaning_curve(train_sizes, train_scores, test_scores,score_name,savefigName):
    '''
    Determine whether the model is under-fitting or over-fitting by learning curve,
    the figure about the (#case_size,scores)
    If the scores are generated by kfold, then #iterations = cv

    :param train_sizes: the #case_size for each iterations with shape (1,#iterations)
    :param train_scores:  the score of each iterations with shape ( #train_sizes,#iterations)
    :param test_scores:  the score of each iterations with shape ( #train_sizes,#iterations)
    :return: 
    '''
    plt.figure()
    fig, ax = plt.subplots()
    colors = ["#0092c7", "#f3e59a", "#9fe0f6",
              "#f3b59a", "#f29c9c", "#22c3aa"]

    for idx, (train_tmp,test_tmp,clf_name) in enumerate(zip(train_scores,test_scores,clf_names)):
        train_mean = np.mean(train_tmp, axis=1)
        train_std = np.std(train_tmp, axis=1)
        test_mean = np.mean(test_tmp, axis=1)
        test_std = np.std(test_tmp, axis=1)

        plt.plot(train_sizes, train_mean, color=colors[idx], marker='o', markersize=5,
                 label='training %s' % clf_name)
        plt.fill_between(train_sizes, train_mean + train_std, train_mean - train_std, alpha=0.5, color=colors[idx])
        plt.plot(train_sizes, test_mean, color=colors[idx], linestyle='--', marker='s', markersize=5,
                 label='validation %s' % clf_name)
        plt.fill_between(train_sizes, test_mean + test_std, test_mean - test_std, alpha=0.5, color=colors[idx])

    plt.xlabel('training size')
    plt.ylabel(score_name)

    plt.legend()
    plt.ylim([0.45,1.05])

    # save figure before showing it.
    if len(savefigName)>0:
        plt.savefig('%s/%s.png' % (getPath('fig'), savefigName),dpi=600)

    plt.show()

def plot_importances_histogram(feat_labels, importances,saveFigName=''):
    feat_size = importances.shape[0]
    indices = np.argsort(importances)[::-1]    # invert to make the biggest one at the first place and reshape

    for f in range(feat_size):
        print("%2d) %-*s %f"%(f+1, 30, feat_labels[f],importances[indices[f]]))

    plt.figure()
    # plt.title('Feature Importances')
    plt.bar(range(feat_size), importances[indices], color='lightblue', align='center')
    plt.xticks(range(feat_size), feat_labels, rotation=90)
    plt.xlim([-1, feat_size])
    plt.tight_layout()
    # save figure before showing it.
    if len(saveFigName) > 0:
        plt.savefig('%s/%s.png' % (getPath('fig'), saveFigName))

    plt.show()

def plotFeaImportance( feaName,feaImp,saveFigName=''):
    colors =  ["#0092c7", "#f3e59a", "#9fe0f6",
              "#f3b59a", "#f29c9c", "#22c3aa"]
    # indices = np.argsort(feaImp)[::-1]    # invert to make the biggest one at the first place and reshape
    # for f in feaName:
    #     print("%s) %-*s %f"%(f, 30, feaName[f],feaImp[indices[f]]))
    color_idx = 5
    plt.figure()
    fig, ax = plt.subplots()
    plt.subplots_adjust(left=0.25,wspace=0.25,hspace=0.25,bottom=0.13,top=0.91) # make sure labels won't be hidden.
    # bottom, width
    y_coords = []
    height = 0.9
    if len(feaName)==4:
        y_coords = list(np.linspace(0,1.5,4))
        height = 0.3
    else:
        y_coords = list(range(len(feaImp)))

    plt.barh(y_coords,feaImp,height=height,align='center', color = colors[color_idx],edgecolor='',alpha=0.5)

    # texting data
    for y_coord, x_length in zip(y_coords,feaImp):
        plt.text(x_length+max(feaImp)/14,y_coord,'%.2f'%x_length,ha='center',va='center')

    plt.yticks(y_coords, feaName)
    plt.xlabel('feature importance')
    # plt.ylabel('feature name')
    # save figure before showing it.
    if len(saveFigName) > 0:
        plt.savefig('%s/%s.png' % (getPath('fig'), saveFigName),dpi=600)
    plt.show()

def showDataOnMap(gdf,cols,band_idx):
    '''
    plot radiance in specific channel indicated by "cols"
    :param gdf:
    :param cols: specify the shown channel's name
    :param cmap:
    :return:
    '''
    world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
    # print(world.continent)
    cmap_list = ['OrRd','Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r']
    # We restrict to Asia and Oceania
    # .tolist() or (world.continent == 'Oceania').tolist()
    ax = world[(world.name == 'China')].\
        plot(color='white', edgecolor='black',linewidth=2)
    gdf_plot = gdf[gdf.band_idx==band_idx]
    gdf_plot.plot(ax=ax,column= cols, cmap=cmap_list[1])
    plt.legend()
    plt.show()
def showDataTopo(gdf,band_idx):
    '''
    plot topology
    :param gdf: GeoDataFrame
    :return:
    '''
    world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
    topos = gdf.topo.unique().tolist()
    topos.sort()
    topos[0],topos[1],topos[2],topos[3],topos[4] = 'sea', 'land low','land high','land water low','land water high'
    colors = ["#0092c7","#f3e59a","#9fe0f6",
              "#f3b59a","#f29c9c","#22c3aa"]
    # We restrict to Asia and Oceania
    # or (world.continent == 'Oceania').tolist()
    ax = world[ (world.name == 'China') ]. \
        plot(color='white', edgecolor='black',linewidth=2)
    # print(world.continent)
    gdf_plot = gdf[gdf['band_idx']==band_idx]
    for idx in range(len(topos)):
        gdf_plot[gdf_plot['topo']==idx].plot(ax=ax, column=['topo'], color=colors[idx],label=topos[idx])
    plt.legend(loc='lower left')
    plt.show()


def plot_multi_pair_line(data_list, scale_comp_label, x_ticks,xlabel,ylabel,yscale=None, savefigName=''):
    '''
    plot lines in pair, one color denotes one class, linestyle denotes the difference.
    :param data_list:
    :param scale_comp_label:
    :param x_ticks:
    :param xlabel:
    :param ylabel:
    :param yscale:
    :param savefigName:
    :return:
    '''
    plt.figure()
    fig, ax = plt.subplots()
    plt.subplots_adjust(left=0.12, right = 0.65, bottom=0.13, top=0.91)  # make sure labels won't be hidden.
    x_ticks_coord = [0,1,2]

    legend_rc_list = []
    legend_label_list = []
    colors = ["#0092c7","#9fe0f6",
              "#f3b59a","#f29c9c","#22c3aa","#f3e59a"]

    for idx, score_tmp in enumerate(data_list):
        legend_rc_tmp, = ax.plot(x_ticks_coord, score_tmp[0], color=colors[idx], marker='o', markersize=5)
        # !!!!Warning!!!!!!!!!!  Do not miss the comma symbol, or you will get error of legend does not support matplotlib.lines.Line2D
        legend_label_tmp = scale_comp_label[idx]
        legend_rc_list.append(legend_rc_tmp)
        legend_label_list.append(legend_label_tmp)
        legend_rc_tmp, = ax.plot(x_ticks_coord, score_tmp[1], color=colors[idx], linestyle='--', marker='s', markersize=5)
        legend_label_tmp = '%s\nscale' % scale_comp_label[idx]
        legend_rc_list.append(legend_rc_tmp)
        legend_label_list.append(legend_label_tmp)

    plt.xlabel(xlabel)
    plt.xticks(x_ticks_coord,x_ticks)
    # legend = ax.legend(tuple(legend_rc_list),tuple(legend_label_list))

    # set legend at outside
    box = ax.get_position()
    ax.set_position([box.x0,box.y0,box.width,box.height])

    legend = ax.legend(tuple(legend_rc_list),tuple(legend_label_list),loc="center left", bbox_to_anchor=(1.01, 0.46),borderaxespad=0.,fontsize=15)
    # set legend with transparent background.
    frame = legend.get_frame()
    frame.set_alpha(1)
    frame.set_facecolor('none')
    frame.set_edgecolor('none') # hidden the edge of legend box.


    plt.ylabel(ylabel)

    if yscale!=None:
        plt.ylim(yscale)

    # save figure before showing it.
    if len(savefigName) > 0:
        plt.savefig('%s/%s.png' % (getPath('showfig'), savefigName),dpi=600)

    plt.show()

def plotFeaImpCurve(fea_imp_df_list,fea_cols_common,legend_labels,xlabel='feature index',ylabel='feature importance (log10)',yscale=None,savefigName=''):
    plt.figure()
    fig, ax = plt.subplots()
    plt.subplots_adjust(left=0.15, right=0.65, bottom=0.13, top=0.91)  # make sure labels won't be hidden.
    feaCols = fea_imp_df_list[-1].columns.tolist()
    x_ticks_coord_all = list(range(len(feaCols)))


    legend_rc_list = []
    legend_label_list = []

    # colors = ["#0092c7", "#9fe0f6",
    #            "#f29c9c", "#22c3aa","#f3b59a", "#f3e59a"]

    for idx, fea_imp in enumerate(fea_imp_df_list):
        data = fea_imp.values.tolist()[0]
        feaColsTmp = fea_imp.columns.tolist()
        x_coord_common = []
        y_common = []
        for colsTmp in fea_cols_common:
            id = feaColsTmp.index(colsTmp)
            x_coord_common.append(id)
            y_common.append(data[id])

        x_ticks_coord = list(range(len(feaColsTmp)))
        legend_rc_tmp, = ax.plot(x_ticks_coord, data,linestyle='', color=colors[idx], marker='o', markersize=3,alpha=2)
        # !!!!Warning!!!!!!!!!!  Do not miss the comma symbol, or you will get error of legend does not support matplotlib.lines.Line2D
        legend_label_tmp = legend_labels[idx]
        legend_rc_list.append(legend_rc_tmp)
        legend_label_list.append(legend_label_tmp)

        ax.plot(x_coord_common, y_common, color=colors[idx],linestyle='',  marker='*', markersize=18)


    plt.xlabel(xlabel)
    # plt.ylabel(ylabel)

    # set legend at outside
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width, box.height])

    legend = ax.legend(tuple(legend_rc_list), tuple(legend_labels), loc="center left", bbox_to_anchor=(1.01, 0.4),
                       borderaxespad=0.,fontsize=15)
    # set legend with transparent background.
    frame = legend.get_frame()
    frame.set_alpha(1)
    frame.set_facecolor('none')
    frame.set_edgecolor('none')  # hidden the edge of legend box.

    if yscale != None:
        plt.ylim(yscale)
    plt.xlim([0,len(x_ticks_coord_all)])

    # save figure before showing it.
    if len(savefigName) > 0:
        plt.savefig('%s/%s.png' % (getPath('showfig'), savefigName),dpi=600)

    plt.show()

def plotAvhrr(df,savefigName=''):

    colors = ["#0092c7", "#f3e59a", "#9fe0f6",
              "#f3b59a", "#f29c9c", "#22c3aa"]
    m = Basemap(llcrnrlon=90,llcrnrlat=5,urcrnrlon=155,urcrnrlat=50,resolution='c',epsg=3415)

    m.drawmapboundary(fill_color= colors[0],zorder=0)
    m.fillcontinents(color='coral',lake_color=colors[0],zorder=1) # configure zorder to show scatter points on it.
    m.drawcoastlines()
    df_plot = df[df['cloud_flag'] == 1]
    x,y = m(df_plot['lon'].values.tolist(),df_plot['lat'].values.tolist()) # have to build geographical coordinates like this.

    m.scatter(x,y, color='white',marker = 'o', s=3,zorder=2)

    lat_tmp = list(range(5,50,10))
    lon_tmp = list(range(90,160,15))

    m.drawparallels(lat_tmp,labels=[True,False,False,False],linewidth=0) # latitude labels
    m.drawmeridians(lon_tmp,labels=[False,False,False,True],linewidth=0) # longitude labels

    if len(savefigName)>0:
        plt.savefig('%s/%s.png'%(getPath('showfig'),savefigName),dpi=600)

    plt.show()



# def plotTopoInColor(df):
#     df_lat =

if __name__=='__main__':
    from logistic.modelCloud import CLoader
    import seaborn as sns
    sns.set_context('talk', font_scale=1, rc=rc)
    loader = CLoader()
    gdf = loader.loadGeoData('raw_seahorse_4.csv',category='typ')
    band_idx = 51895
    showDataTopo(gdf,band_idx)
    showDataOnMap(gdf,'ch921',band_idx)
    showDataOnMap(gdf, 'ch386',band_idx)
    showDataOnMap(gdf, 'ch306',band_idx)
    showDataOnMap(gdf, 'ch241',band_idx)